# JVM 구조와 동작 원리

JVM은 자바 애플리케이션의 실행 환경으로, 클래스 로딩, 메모리 관리, 실행, 최적화, 가비지 컬렉션(GC) 등 다양한 기능을 수행합니다.

---

## 1. JVM 아키텍처 개요 🔍 ✅

JVM은 여러 서브시스템으로 구성되어 있으며, 각각의 서브시스템은 자바 애플리케이션 실행에 필수적인 역할을 합니다.  
**주요 구성 요소:**
- ✅ **클래스 로더 서브시스템 (Class Loader Subsystem)**
- ✅ **런타임 데이터 영역 (Runtime Data Areas)**
- ✅ **실행 엔진 (Execution Engine)**
- ✅ **네이티브 인터페이스 (Native Interface)**
- ✅ **가비지 컬렉션 (Garbage Collection) 및 메모리 최적화**

---

## 2. 클래스 로더 서브시스템 (Class Loader Subsystem) 📂 ✅

### 2.1 역할 및 동작 단계

클래스 로더는 .class 파일(바이트코드)을 메모리로 로드하며, 다음 단계로 클래스를 준비합니다:

- ✅ **로딩 (Loading):**  
  - 파일 시스템, 네트워크 등에서 .class 파일을 읽어 바이트 배열로 가져오고,  
  - `java.lang.Class` 객체로 생성합니다.
  
- ✅ **검증 (Verification):**  
  - 바이트코드의 형식과 보안 규칙 준수를 검사하여,  
  - **타입 안전성과 보안**을 보장합니다. 🔒

- ✅ **준비 (Preparation):**  
  - 클래스 변수(정적 변수)에 기본값(0, false, null 등)을 할당합니다.
  
- ✅ **해결 (Resolution):**  
  - 심볼릭 참조를 실제 메모리 주소로 변환하여,  
  - 클래스 간의 관계를 해석합니다.
  
- ✅ **초기화 (Initialization):**  
  - static 초기화 블록과 변수를 실제 값으로 설정하여,  
  - 클래스를 “완전히 준비”합니다.

### 2.2 부모-자식 모델 (Parent Delegation Model) 🤝 ✅

- ✅ **부모 위임 모델:**  
  모든 클래스 로더는 자신의 부모에게 먼저 로드 요청을 위임합니다.
  - **Bootstrap Class Loader:** 자바 표준 라이브러리 로드
  - **Extension Class Loader:** JRE 확장 디렉토리 로드
  - **System/Application Class Loader:** 애플리케이션 클래스 경로 로드
- ✅ **장점:**  
  - 보안 강화 (시스템 클래스를 보호)  
  - 일관성 유지 (동일 클래스 중복 로딩 방지)

---

## 3. 런타임 데이터 영역 (Runtime Data Areas) 🧠 ✅

JVM은 실행 중 다음 메모리 영역을 관리합니다:

### 3.1 메서드 영역 (Method Area)

- ✅ **역할:** 클래스 구조 정보(상수 풀, 필드, 메서드, 인터페이스)를 저장  
- ✅ **특징:**  
  - 모든 스레드가 공유  
  - 자바 8 이전 PermGen → 자바 8 이상 Metaspace (네이티브 메모리)

### 3.2 힙 (Heap)

- ✅ **역할:** 모든 객체와 배열이 저장되는 영역  
- ✅ **세부 구성:**  
  - **Young Generation:**  
    - Eden 영역: 새 객체 저장  
    - Survivor 영역: Eden에서 살아남은 객체  
    - Minor GC가 자주 발생  
  - **Old Generation:**  
    - 오래 살아남은 객체들이 저장됨  
    - Major 또는 Full GC 발생 시 대상

### 3.3 스택 (Stack)

- ✅ **역할:**  
  - 각 스레드별로 생성  
  - 메서드 호출 시 생성된 프레임(지역 변수, 피연산자 스택, 리턴 주소 등)을 저장  
- ✅ **특징:**  
  - 스레드 독립적  
  - LIFO(후입선출) 방식으로 빠른 메모리 할당/해제

### 3.4 프로그램 카운터 (PC) 레지스터

- ✅ **역할:**  
  - 각 스레드의 현재 실행 중인 JVM 명령어(바이트코드)의 주소를 저장  
- ✅ **특징:** 스레드별로 독립적, 실행 위치 추적

### 3.5 네이티브 메서드 스택 (Native Method Stack)

- ✅ **역할:**  
  - JNI나 네이티브 코드 실행 시 사용되는 스택  
- ✅ **특징:** 네이티브 메서드의 실행 정보를 관리, 스레드마다 별도 존재

---

## 4. 실행 엔진 (Execution Engine) ⚙️ ✅

실행 엔진은 JVM에 로드된 바이트코드를 실제 기계어로 변환해 실행하는 핵심 컴포넌트입니다.

### 4.1 인터프리터 (Interpreter)

- ✅ **역할:**  
  - 바이트코드를 한 줄씩 해석하여 실행
- ✅ **장점:**  
  - 빠른 시작 (컴파일 없이 즉시 실행)
- ✅ **단점:**  
  - 반복 실행 시 성능 저하 가능

### 4.2 JIT 컴파일러 (Just-In-Time Compiler)

- ✅ **역할:**  
  - “핫스팟” 코드(반복 실행되는 코드)를 기계어로 컴파일하여 성능을 향상
- ✅ **세부 내용:**  
  - **C1 컴파일러:** 빠른 컴파일, 낮은 최적화, 응답성 중시  
  - **C2 컴파일러:** 깊은 최적화, 높은 성능 제공, 서버 애플리케이션 적합  
  - **OSR (On-Stack Replacement):** 실행 중인 메서드의 일부를 최적화된 기계어 코드로 대체
- ✅ **장점:** 반복 실행되는 코드의 성능 극대화
- ✅ **단점:** 컴파일 오버헤드와 복잡한 최적화 과정

---

## 5. 가비지 컬렉션 (Garbage Collection) ♻️ ✅

JVM은 힙 영역에서 더 이상 사용되지 않는 객체를 자동으로 제거하여 메모리 누수를 방지합니다.

### 5.1 가비지 컬렉션 기본 원리

- ✅ **마크 (Mark):**  
  - 도달 가능한 객체에 마크를 하여 살아있는 객체 식별
- ✅ **스윕 (Sweep):**  
  - 마크되지 않은 객체를 메모리에서 제거
- ✅ **마크-컴팩트 (Mark-Compact):**  
  - 남은 객체를 한쪽으로 모아 메모리 단편화를 줄임

### 5.2 세대별 가비지 컬렉션 (Generational GC)

- ✅ **Young Generation:**  
  - **Eden 영역:** 새 객체 저장  
  - **Survivor 영역:** Eden에서 살아남은 객체 이동  
  - **Minor GC:** 빠르게 수거, 짧은 정지 시간
- ✅ **Old Generation:**  
  - 오래 살아남은 객체가 저장됨  
  - **Major GC / Full GC:** 상대적으로 긴 정지 시간 발생
- ✅ **메타스페이스 (Metaspace):**  
  - 자바 8부터 PermGen 대신 사용, 클래스 메타데이터 저장, 네이티브 메모리 사용

### 5.3 주요 GC 알고리즘

- ✅ **Serial GC:** 단일 스레드로 단순하게 수행  
- ✅ **Parallel GC:** 멀티 스레드로 병렬 수행하여 정지 시간을 줄임  
- ✅ **CMS (Concurrent Mark-Sweep) GC:** 애플리케이션 스레드와 동시에 GC 수행, 정지 시간 최소화  
- ✅ **G1 (Garbage-First) GC:** 힙을 여러 영역으로 분할, 가장 많은 가비지를 포함한 영역부터 우선 수거

### 5.4 GC 튜닝

- ✅ **JVM 옵션 사용:**  
  - 예: `-Xms`, `-Xmx`, `-XX:+UseG1GC` 등으로 힙 크기 및 GC 알고리즘 조정
- ✅ **프로파일링 도구 사용:**  
  - VisualVM, JConsole, GC 로그 분석 도구 등을 통해 메모리 사용 패턴 분석

---

## 6. 네이티브 인터페이스 (Native Interface) 🔌 ✅

### 6.1 JNI (Java Native Interface)

- ✅ **역할:**  
  - 자바 코드와 네이티브 코드(C/C++) 간의 상호 운용 지원
- ✅ **동작 원리:**  
  - 자바 애플리케이션에서 네이티브 메서드 호출 시, JNI를 통해 네이티브 라이브러리가 로드되고  
    자바 객체와 네이티브 메모리 간 데이터 교환이 이루어집니다.
- ✅ **특징:**  
  - 네이티브 코드와 통합하여 성능 향상 가능  
  - 메모리 관리와 예외 처리에 주의 필요

---

## 7. JVM 최적화 기법 ⚡ ✅

### 7.1 JIT 컴파일 최적화

- ✅ **핫스팟 분석:**  
  - 자주 실행되는 코드 영역을 분석해 기계어로 최적화합니다.
- ✅ **인라인 캐싱:**  
  - 메서드 호출 오버헤드를 줄이기 위해 호출 대상 메서드를 인라인으로 삽입.
- ✅ **OSR (On-Stack Replacement):**  
  - 실행 중인 메서드의 일부를 최적화된 기계어 코드로 대체하여 성능 향상.

### 7.2 GC 튜닝 및 메모리 관리

- ✅ **힙 사이즈 조정:**  
  - 초기 힙 크기와 최대 힙 크기를 애플리케이션 요구에 맞게 설정.
- ✅ **GC 알고리즘 선택:**  
  - 응답성, 처리량 등 애플리케이션 특성에 따라 G1, CMS 등 적합한 알고리즘 선택.
- ✅ **프로파일링 및 모니터링:**  
  - VisualVM, JConsole, GC 로그 분석 등을 통해 메모리 사용과 GC 동작을 최적화.

---

## 8. JVM 동작 요약 📑 ✅

1. **소스 코드 작성 및 컴파일**  
   - `.java` 파일 → `javac` 컴파일러 → `.class` 파일(바이트코드 생성)

2. **클래스 로딩 및 초기화**  
   - 클래스 로더가 .class 파일을 메모리에 로드하고, 검증, 준비, 해결, 초기화 단계를 거쳐 등록

3. **바이트코드 실행**  
   - 실행 엔진(인터프리터 또는 JIT 컴파일러)이 바이트코드를 기계어로 변환하여 실행  
   - 각 스레드는 독립적인 스택, PC 레지스터, 네이티브 메서드 스택 사용

4. **메모리 관리 및 GC**  
   - 힙에서 객체 생애 주기를 관리하며, GC가 불필요한 객체를 자동 제거  
   - 세대별 GC 및 다양한 알고리즘으로 단편화 최소화

5. **네이티브 코드 연동 (JNI)**  
   - 네이티브 인터페이스를 통해 자바와 C/C++ 코드 상호 운용, 네이티브 자원 관리

---

## 결론 🎯 ✅

JVM은 자바 애플리케이션의 실행 환경으로,  
- **클래스 로더**를 통해 바이트코드를 로드 및 초기화하고,  
- **런타임 데이터 영역**(힙, 스택, 메서드 영역, PC 레지스터 등)을 통해 메모리를 관리하며,  
- **실행 엔진**이 바이트코드를 해석 및 최적화하여 실제 기계어로 실행합니다.  
- **가비지 컬렉션**은 불필요한 객체를 자동 제거하여 메모리 누수를 방지하며,  
- **JNI**를 통해 네이티브 코드와의 연동이 가능합니다.

또한, **JIT 컴파일, 인라인 캐싱, OSR** 등 다양한 최적화 기법과 GC 튜닝을 통해 JVM은 높은 성능과 안정성을 제공합니다.

> **"JVM의 내부 구조와 동작 원리를 깊이 이해하면, 자바 애플리케이션의 성능 최적화와 안정적인 메모리 관리를 위한 효과적인 전략을 수립할 수 있다!"** 🚀
