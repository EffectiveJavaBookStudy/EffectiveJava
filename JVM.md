# JVM 구조와 동작 원리

JVM은 자바 애플리케이션의 실행 환경으로, 클래스 로딩, 메모리 관리, 실행, 최적화, 가비지 컬렉션(GC) 등 다양한 기능을 수행합니다.

---

## 1. JVM 아키텍처 개요 🔍 ✅

JVM은 여러 서브시스템으로 구성되어 있으며, 각각의 서브시스템은 자바 애플리케이션 실행에 필수적인 역할을 합니다.  
**주요 구성 요소:**
- ✅ **클래스 로더 서브시스템 (Class Loader Subsystem)**
- ✅ **런타임 데이터 영역 (Runtime Data Areas)**
- ✅ **실행 엔진 (Execution Engine)**
- ✅ **네이티브 인터페이스 (Native Interface)**
- ✅ **가비지 컬렉션 (Garbage Collection) 및 메모리 최적화**

![image](https://github.com/user-attachments/assets/b9310d36-e2db-43eb-8743-02632c52b590)

---

## 2. 클래스 로더 서브시스템 (Class Loader Subsystem) 📂

### 2.1 역할 및 동작 단계

개발자는 java 파일을 작성을 합니다. 이후 컴파일러 ( java compiler )가 .java -> .class 파일로 바꿔줍니다.

클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data area), 즉 JVM의 메모리에 올립니다.

클래스 로더의 세부 동작

- ✅ **로딩 (Loading):**  
  - 파일 시스템, 네트워크 등에서 .class 파일을 읽어 바이트 배열로 가져오고,  
  - `java.lang.Class` 객체로 생성합니다.
  - 클래스 파일을 가져와서 JVM의 메모리에 로드합니다.
  
- ✅ **검증 (Verification):**  
  - 바이트코드의 형식과 보안 규칙 준수를 검사하여,  
  - **타입 안전성과 보안**을 보장합니다.
  - JVM 명세에 명시된 대로 구성되어 있는지 검사

- ✅ **준비 (Preparation):**  
  - 클래스 변수(정적 변수)에 기본값(0, false, null 등)을 할당합니다.
  - 클래스가 필요로 하는 메모리를 할당합니다. (필드, 메서드, 인터페이스 등등)
  
- ✅ **해결 (Resolution):**  
  - 심볼릭 참조를 실제 메모리 주소로 변환하여,  
  - 클래스 간의 관계를 해석합니다.
  
- ✅ **초기화 (Initialization):**  
  - static 초기화 블록과 변수를 실제 값으로 설정하여,  
  - 클래스를 “완전히 준비”합니다.

### 2.2 부모-자식 모델 (Parent Delegation Model) 🤝

클래스 로더는 부모-자식 형태로 서로 연결되어 있고, 위임(delegation) 모델에 의해 동작합니다. 

특정 애플리케이션 클래스를 JVM에 로드하라는 요청이 있다면 먼저 요청을 받는 시스템 클래스 로더는 확장 클래스 로더에게, 

확장 클래스 로더는 부트스트랩 클래스 로더에게 우선 작업을 위임시킵니다. 이후 부트스트랩 클래스 로더가 클래스를 로드하는데

실패하면 확장 클래스 로더가 작업 처리를 시도하고, 확장 클래스 로더가 클래스를 로드하는데 실패하면 

다시 시스템 클래스 로더가 클래스 로드를 시도하게 됩니다.


- ✅ **부모 위임 모델:**  
  모든 클래스 로더는 자신의 부모에게 먼저 로드 요청을 위임합니다.
  - **Bootstrap Class Loader:** 자바 표준 라이브러리 로드
  - **Extension Class Loader:** JRE 확장 디렉토리 로드
  - **System/Application Class Loader:** 애플리케이션 클래스 경로 로드
    
- ✅ **장점:**  
  - 보안 강화 (시스템 클래스를 보호)  
  - 일관성 유지 (동일 클래스 중복 로딩 방지)

---

## 3. 런타임 데이터 영역 (Runtime Data Areas) 🧠

JVM은 실행 중 다음 메모리 영역을 관리합니

![image](https://github.com/user-attachments/assets/257281b9-033d-461d-8ec6-9374fe585d82)


### 3.1 메서드 영역 (Method Area)

- ✅ **역할:** 클래스 구조 정보(상수 풀, 필드, 메서드, 인터페이스)를 저장  
- ✅ **특징:**  
  - 모든 스레드가 공유  
  - 자바 8 이전 PermGen → 자바 8 이상 Metaspace (네이티브 메모리)

### 3.2 힙 (Heap)

- ✅ **역할:** 모든 객체와 배열이 저장되는 영역  
- ✅ **세부 구성:**  
  - **Young Generation:**  
    - Eden 영역: 새 객체 저장  
    - Survivor 영역: Eden에서 살아남은 객체  
    - Minor GC가 자주 발생  
  - **Old Generation:**  
    - 오래 살아남은 객체들이 저장됨  
    - Major 또는 Full GC 발생 시 대상

### 3.3 스택 (Stack)

- ✅ **역할:**  
  - 각 스레드별로 생성  
  - 메서드 호출 시 생성된 프레임(지역 변수, 피연산자 스택, 리턴 주소 등)을 저장  
- ✅ **특징:**  
  - 스레드 독립적  
  - LIFO(후입선출) 방식으로 빠른 메모리 할당/해제

### 3.4 프로그램 카운터 (PC) 레지스터

- ✅ **역할:**  
  - 각 스레드의 현재 실행 중인 JVM 명령어(바이트코드)의 주소를 저장  
- ✅ **특징:** 스레드별로 독립적, 실행 위치 추적

### 3.5 네이티브 메서드 스택 (Native Method Stack)

- ✅ **역할:**  
  - JNI나 네이티브 코드 실행 시 사용되는 스택  
- ✅ **특징:** 네이티브 메서드의 실행 정보를 관리, 스레드마다 별도 존재

> JNI란? -> 6번에서 나옴
>
> 자바 네이티브 인터페이스는 자바 가상머신(JVM)위에서 실행되고 있는 자바코드가
> 네이티브 응용 프로그램(하드웨어와 운영 체제 플랫폼에 종속된 프로그램들) 그리고 C, C++ 그리고 어셈블리 같은
> 다른 언어들로 작성된 라이브러리들을 호출하거나 반대로 호출되는 것을 가능하게 하는 프로그래밍 프레임워크

#### 📌 사용이유
- 일부 하드웨어를 처리해야 하는 필요성
- 매우 까다로운 프로세스의 성능 향상
- Java로 다시 작성하는 대신 재사용하려는 기존 라이브러리
---

## 4. 실행 엔진 (Execution Engine) ⚙️

자바의 코드가 실행되기 위해서는 .java -> .class 의 과정이 필요하다고 했었습니다.

이후 JVM의 실행 엔진 내에 있는 자바 인터프리터를 통해 바이트코드를 특정 환경의 기계어로 번역하고 실행합니다.

실행 엔진에서는 인터프리터와, JIT 컴파일러를 활용해서 컴파일이 된 코드를 인터프리팅 합니다.

### 4.1 인터프리터 (Interpreter)

- ✅ **역할:**  
  - 바이트코드를 한 줄씩 해석하여 실행
- ✅ **장점:**  
  - 빠른 시작 (컴파일 없이 즉시 실행)
- ✅ **단점:**  
  - 반복 실행 시 성능 저하 가능

### 자바 실행엔진은 왜 인터프리터를 사용할까?

1. 인터프리터는 플랫폼에 종속되지 않는다.

자바 인터프리터는 자바 컴파일러를 통해 생성된 바이트코드를 한 줄씩 읽어 기계어로 번역하고 실행합니다.

만약 JVM 내에서 컴파일러를 사용하여 바이트코드의 목적 파일을 생성한다면 이는 기계에 종속되는 파일이기 때문입니다.

하지만 이와 모순되게 인터프리터는 컴파일러보다 실행 속도가 너무 느리기 때문에 이를 해결하고자 JVM은 부분적으로 JIT 컴파일러를 사용하여 바이트코드를 컴파일하여 사용합니다.

2. 초기 실행 속도를 빠르게 할 수 있다.

자바 바이트코드 전체를 프로그램 수행 초기에 모두 읽어 컴파일하게 되면 초기 실행 속도가 느리다. 인터프리터를 사용하면 초기 실행 속도를 높일 수 있습니다.

3. 보안적으로 장점이 있다.

자바 바이트코드는 컴퓨터와 프로그램 사이에 별도의 버퍼 역할을 해줍니다. 인터넷이나 기타 매체를 통해 신뢰할 수 없는 프로그램을 다운로드하여 실행하는 경우 

어느 정도 안전이 보장될 수 있지만 자바 인터프리터를 사용함으로써 바이러스나 기타 악성 프로그램에 대응하는 가드 같은 보안 계층에 의해 보호될 수 있다.

### 4.2 JIT 컴파일러 (Just-In-Time Compiler)

- ✅ **역할:**  
  - “핫스팟” 코드(반복 실행되는 코드)를 기계어로 컴파일하여 성능을 향상
- ✅ **세부 내용:**  
  - **C1 컴파일러:** 빠른 컴파일, 낮은 최적화, 응답성 중시  
  - **C2 컴파일러:** 깊은 최적화, 높은 성능 제공, 서버 애플리케이션 적합  
  - **OSR (On-Stack Replacement):** 실행 중인 메서드의 일부를 최적화된 기계어 코드로 대체
- ✅ **장점:** 반복 실행되는 코드의 성능 극대화
- ✅ **단점:** 컴파일 오버헤드와 복잡한 최적화 과정

자바는 코드를 실행하기 위해서는 바이트코드로 컴파일하는 과정과 바이트코드를 인터프리트하는 과정을 거쳐야 하기 때문에 컴파일 과정만 필요한 다른 프로그래밍 언어보다 느립니다. 

거기에 더하여 인터프리터는 컴파일러보다 느리기 때문에 성능 문제기 발생할 수밖에 없었습니다. 이러한 문제를 개선하기 위해 나온 것이 JIT 컴파일러입니다.

원래 자바의 JVM에서는 인터프리터 방식만 사용했지만 성능 문제가 발생했고 JIT 컴파일러를 추가해서 성능을 올리게 되었습니다.

![image](https://github.com/user-attachments/assets/cb9ec718-4cab-4da9-a8ca-526dcac4b947)


---

## 5. 가비지 컬렉션 (Garbage Collection) ♻️ ✅

JVM은 힙 영역에서 더 이상 사용되지 않는 객체를 자동으로 제거하여 메모리 누수를 방지합니다.

### 5.1 가비지 컬렉션 기본 원리

- ✅ **마크 (Mark):**  
  - 도달 가능한 객체에 마크를 하여 살아있는 객체 식별
- ✅ **스윕 (Sweep):**  
  - 마크되지 않은 객체를 메모리에서 제거
- ✅ **마크-컴팩트 (Mark-Compact):**  
  - 남은 객체를 한쪽으로 모아 메모리 단편화를 줄임

### 5.2 세대별 가비지 컬렉션 (Generational GC)

- ✅ **Young Generation:**  
  - **Eden 영역:** 새 객체 저장  
  - **Survivor 영역:** Eden에서 살아남은 객체 이동  
  - **Minor GC:** 빠르게 수거, 짧은 정지 시간
- ✅ **Old Generation:**  
  - 오래 살아남은 객체가 저장됨  
  - **Major GC / Full GC:** 상대적으로 긴 정지 시간 발생
- ✅ **메타스페이스 (Metaspace):**  
  - 자바 8부터 PermGen 대신 사용, 클래스 메타데이터 저장, 네이티브 메모리 사용

### 5.3 주요 GC 알고리즘

- ✅ **Serial GC:** 단일 스레드로 단순하게 수행  
- ✅ **Parallel GC:** 멀티 스레드로 병렬 수행하여 정지 시간을 줄임  
- ✅ **CMS (Concurrent Mark-Sweep) GC:** 애플리케이션 스레드와 동시에 GC 수행, 정지 시간 최소화  
- ✅ **G1 (Garbage-First) GC:** 힙을 여러 영역으로 분할, 가장 많은 가비지를 포함한 영역부터 우선 수거

### 5.4 GC 튜닝

- ✅ **JVM 옵션 사용:**  
  - 예: `-Xms`, `-Xmx`, `-XX:+UseG1GC` 등으로 힙 크기 및 GC 알고리즘 조정
- ✅ **프로파일링 도구 사용:**  
  - VisualVM, JConsole, GC 로그 분석 도구 등을 통해 메모리 사용 패턴 분석

---

## 6. 네이티브 인터페이스 (Native Interface) 🔌

### 6.1 JNI (Java Native Interface)

- ✅ **역할:**  
  - 자바 코드와 네이티브 코드(C/C++) 간의 상호 운용 지원
- ✅ **동작 원리:**  
  - 자바 애플리케이션에서 네이티브 메서드 호출 시, JNI를 통해 네이티브 라이브러리가 로드되고  
    자바 객체와 네이티브 메모리 간 데이터 교환이 이루어집니다.
- ✅ **특징:**  
  - 네이티브 코드와 통합하여 성능 향상 가능  
  - 메모리 관리와 예외 처리에 주의 필요

---

## 7. JVM 최적화 기법 ⚡

### 7.1 JIT 컴파일 최적화

- ✅ **핫스팟 분석:**  
  - 자주 실행되는 코드 영역을 분석해 기계어로 최적화합니다.
- ✅ **인라인 캐싱:**  
  - 메서드 호출 오버헤드를 줄이기 위해 호출 대상 메서드를 인라인으로 삽입.
- ✅ **OSR (On-Stack Replacement):**  
  - 실행 중인 메서드의 일부를 최적화된 기계어 코드로 대체하여 성능 향상.

### 7.2 GC 튜닝 및 메모리 관리

- ✅ **힙 사이즈 조정:**  
  - 초기 힙 크기와 최대 힙 크기를 애플리케이션 요구에 맞게 설정.
- ✅ **GC 알고리즘 선택:**  
  - 응답성, 처리량 등 애플리케이션 특성에 따라 G1, CMS 등 적합한 알고리즘 선택.
- ✅ **프로파일링 및 모니터링:**  
  - VisualVM, JConsole, GC 로그 분석 등을 통해 메모리 사용과 GC 동작을 최적화.

---

## 8. JVM 동작 요약 📑 

1. **소스 코드 작성 및 컴파일**  
   - `.java` 파일 → `javac` 컴파일러 → `.class` 파일(바이트코드 생성)

2. **클래스 로딩 및 초기화**  
   - 클래스 로더가 .class 파일을 메모리에 로드하고, 검증, 준비, 해결, 초기화 단계를 거쳐 등록

3. **바이트코드 실행**  
   - 실행 엔진(인터프리터 또는 JIT 컴파일러)이 바이트코드를 기계어로 변환하여 실행  
   - 각 스레드는 독립적인 스택, PC 레지스터, 네이티브 메서드 스택 사용

4. **메모리 관리 및 GC**  
   - 힙에서 객체 생애 주기를 관리하며, GC가 불필요한 객체를 자동 제거  
   - 세대별 GC 및 다양한 알고리즘으로 단편화 최소화

5. **네이티브 코드 연동 (JNI)**  
   - 네이티브 인터페이스를 통해 자바와 C/C++ 코드 상호 운용, 네이티브 자원 관리

---

## 결론 🎯

JVM은 자바 애플리케이션의 실행 환경으로,  
- **클래스 로더**를 통해 바이트코드를 로드 및 초기화하고,  
- **런타임 데이터 영역**(힙, 스택, 메서드 영역, PC 레지스터 등)을 통해 메모리를 관리하며,  
- **실행 엔진**이 바이트코드를 해석 및 최적화하여 실제 기계어로 실행합니다.  
- **가비지 컬렉션**은 불필요한 객체를 자동 제거하여 메모리 누수를 방지하며,  
- **JNI**를 통해 네이티브 코드와의 연동이 가능합니다.

또한, **JIT 컴파일, 인라인 캐싱, OSR** 등 다양한 최적화 기법과 GC 튜닝을 통해 JVM은 높은 성능과 안정성을 제공합니다.

> **"JVM의 내부 구조와 동작 원리를 깊이 이해하면, 자바 애플리케이션의 성능 최적화와 안정적인 메모리 관리를 위한 효과적인 전략을 수립할 수 있다!"** 🚀
