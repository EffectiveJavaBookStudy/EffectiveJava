# Garbage Collection

## 😁 GC는 처리량과 응답시간 사이의 Trade Off를 생각해서 선택해야한다.

#### 이게 결국 GC를 공부하는 이유입니다.

GC에 들어가기 앞서서 결국 GC를 공부하는 이유는 우리가 현장에서 상황에 맞게 GC를 튜닝하거나 선택해야되기 때문이죠.

각 GC 알고리즘의 Trade Off를 알고 추후에 올바르게 사용합시다 !!! 

#### OutOfMemory 가 발생하면 GC를 확인해보자 ! 

---

## 🪟 Garbage Collection이란? 

말 그대로 "쓰레기 수집"입니다. 자바 프로그램에서 쓰레기는 더 이상 사용하지 않고 메모리를 사용하는 객체입니다. 객체들은 Heap영역에 생성되고, 더이상 사용(참조)되지 않으면 정리를 해줘야겠죠?

이게 자바라는 언어가 실행속도가 C/C++보다 느린 이유입니다. 하지만 그와 동시에 메모리 관련 신경을 덜써도 되니 프로그래머입장에선 편한거죠.

하지만 이러한 GC는 언제 실행될 지도 명확하지 않고, GC가 진행되는 동안에 다른 동작을 멈추는 STW(Stop The World)가 발생합니다.

> STW : GC관련 Thread이외에 다른 모든 Thread는 멈춘다.

### 이 STW시간이 응답시간과 처리량 Trade Off의 핵심입니다.

## 🚩 쓰레기를 고르는 기준

결국 GC녀석은 쓰레기를 골라야 되는 데, 어떤 기준을 고를까요? 

그 기준은 "참조"입니다. 객체가 참조가 되고 있다면 Reachable , 아니라면 unReachable 입니다.

unReachable한 객체를 골라서 청소합니다.

## 🤔 어디서?

Heap에서 이뤄지는 데 여기서 Heap의 구조가 특이합니다. Heap공간은 설계될 때 2가지를 전제로 설계되었습니다.

1. 대부분의 객체는 금방 UnReachable이 된다.
2. 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.

이 전제를 기준으로 힙 영역은 2가지로 구분됩니다.

![alt text](/image/image-GCheap.png)

새로운 객체가 할당 되는 Young 영역, 여기서 또 3가지로 나뉘어 효율적으로 일을 처리합니다. 

1. Eden : 새로운 객체 
2. Surviovr 0/1 : 1번이상의 GC에서 살아남은 객체
   1. 0과 1 둘 중 하나의 영역은 비어있어야 합니다.

오래된 객체가 쌓이는 Old 영역

그리고 JDK 8이후로는 기존의 Permanent가 Metaspace로 힙에서 Native Method Area로 이동했습니다. 해당에는 생성된 객체들의 Meta정보가 저장되는 공간이죠.

## 🤔 어떻게?

###  minor GC와 major GC

### Ⓜ️ Minor GC

마이너 GC는 Young 영역에서 이루어집니다. 모든 객체는 Young영역에서 생성이 됩니다. 물론 사이즈가 크면 자동으로 Old에서 생성이 되죠. 그림에서도 봤겠지만 Young영역이 Old 영역보다 작기에 처리할 객체를 찾는 시간이 짧습니다. 

### 과정

![alt text](/image/image-minor1.png)

우선 Minor GC의 조건은 객체들이 생성되서 Eden영역이 가득찬 경우입니다.
여기서 GC를 할 객체를 Mark합니다. 

Mark 과정은 객체를 찾는 과정입니다.

![alt text](/image/image-minor2.png)

여기서 Mark가 끝난 객체를 survivor0으로 이동합니다.

그리고 Eden영역을 통쨰로 버립니다. 이게 흔히 말하는 Mark - Sweep - Compacting 과정과 다른 점입니다. 즉 Sweep하고 Compacting을 하지 않기에 속도에서 훨씬 빠른거죠.

![alt text](/image/image-minor3.png)

또 다시 Eden 영역이 꽉차면 Minor GC가 발생하고 Eden과 survivor0에 있는 객체를 Mark해서 survivor1로 옮겨줍니다. 그리고 survior0과 Eden 영역은 통째로 제거되겠죠.

여기서 중요한 것이 객체에 1이라는 숫자가 생겼습니다. 이는 임계값으로 이 숫자가 지정한 숫자를 넘어가면 OLD영역으로 Promotion 즉 승급됩니다. 그러면 OLD가 꽉차면 그때 Major GC가 일어나겠죠?? 

![alt text](/image/image-minor4.png)

이렇게 전에 말했던 Survivor영역은 0과 1 둘중 하나는 꼭 비어야된다 가 성립하게 됩니다. 이러한 Minor GC는 Copying GC라고 불리며 해당 공간에서 마킹한 객체만 복사해서 다른 곳에 붙여넣기하고 이전 공간은 제거해버리기에 둘 중 하나만 사용이 되어야 되는 것입니다.

---
### Ⓜ️ Major GC(Full GC)

Major GC는 그림 첨부 안해도 될것같습니다. 단순하게 Eden영역에서 Promotion되거나 에초에 사이즈가 큰 객체들이 쌓여서 꽉차게되면 그때 GC가 발생합니다. 당연히 이때 발생하는 GC는 영역도 훨씬 크기에 Mark하는데 시간도 오래걸리겠죠?? 

이때 흔히 말하는 STW시간이 길다.. 이말이 나오는데 사실 Minor GC에도 잠깐씩 멈추긴한다고합니다.

그리고 Full GC를 할 때 흔히 알려진 GC 수행방법인

**Mark - Sweep - Compacting** 

위의 방식이 쓰입니다. 말그대로 Mark해서 안쓰는 객체를 고르고 Sweap 청소합니다. 근데 이때는 Old 영역은 분리가 안되어 있기에 복사하고 통째로 버리는게 안되서 솎아내는 작업을 하는 것이고, 당연히 이게 더 오래걸리겠죠?? 

그리고는 흔이 아는 메모리의 단편화 문제 때문에 다시 메모리들을 땡겨서 정리해줍니다.


> Mark 과정시 객체의 참조에 참조를 따라가서 진짜 참조가 되고 있는 지 확인합니다. 이때 Root Space라는 Heap 객체를 참조하고 있는 영역인 Stack, Native Method Area 등을 가서 확인을 합니다.
>
> 또한 특이하게 Old 영역에서 Young영역 객체를 참조하는 경우를 대비해 "Card Table"이라는 영역으로 Old 영역의 객체중 Young 영역에 객체를 참조하고 있으면 표시해줍니다.
>
> 만약 표시를 안해주면 OLD영역을 Mark해서 참조를 찾는 과정에 다 뒤지기에 성능상 아주 안좋겠죠


---

# ✨ 알고리즘 소개

여기서는 가장 기본적인 알고리즘, 처리량에 강점을 둔 알고리즘, 둘 사이 밸런스를 잘잡은 알고리즘 이런식으로 확인해보겠습니다.

결국 내부 GC 알고리즘 동작에 집중하기보다 장단점을 아는 게 중요하다고 생각했습니다.

## 1. Serial GC 

서버의 CPU코어가 1개일 때 사용하기 위해 개발된 GC.

싱글 쓰레드로 작동하기에 STW시간이 가장 길고 아예 쓸일이 없다고 보면됩니다.

하지만 말 그대로 GC는 메모리가 꽉찰때까지 실행을 안하기에, GC가 실행되는 STW 시간 이외에는 CPU를 App에만 사용할 수 있겠죠?? 처리량 측면에서는 좋습니다.

## 2. Parellel GC 

JDK 8의 기본 GC입니다. 기본적인 알고리즘은 Serial과 같지만, Young 영역의 Minor GC를 병렬적으로 처리합니다. OLD는 그대로 single하게 작동.

## 3. Parellel Old GC

2번을 개선한 버전으로 Old에서도 멀티쓰레드로 병렬적으로 GC를 수행합니다 .

특이하게 Mark - Summary - Compacting으로 수행합니다.

Summary는 Compacting과정에서 메모리를 정리하는 그 과정을 효율적으로 개선한 방식이죠.

Sweep 단계 없이, 살아남은 객체들의 위치를 미리 계산,살아남은 객체들이 Compact 단계에서 이동해야 할 위치를 사전에 결정,즉 메모리 정리가 어떻게 이루어질지를 미리 분석하고 최적화하는 과정입니다.

> 사실 이런 디테일 까지는 몰라도 된다고 봅니다. 장점만 알면되죠.

## 4. CMS GC 

사실 이 녀석도 Deprecated 된 녀석입니다.

App쓰레드와 GC쓰레드를 동시에 실행해서 STW을 줄이는 방식이죠. 하지만 이 녀석은 Compacting을 수행하지 않습니다. 그러면 당연히 프로그램을 돌리다보면 메모리 공간이 터지겠죠? 메모리 단편화 문제 때문에 사용하지 않습니다.

## 5. G1 GC (Garbage First)

쓰레기 우선 !!!! 

즉 가비지가 찬 영역을 우선으로 처리하는 GC입니다. 결국 모든 문제는 Heap영역에서 나뉘어진 두 부분이 GC를 구분하고 시간을 오래걸리는 등 이런 문제가 생긴거기도하죠.

그래서 G1 GC는 Heap을 여러개의 Region으로 나눠서 관리합니다.

영역만 나눠놓고 그 영역에 동적으로 너는 Eden이야 survivor이야 이렇게 부여하는 거죠.

![alt text](/image/image-G1.png)

이 방법이 가장 응답속도와 처리량 사이에 균형을 잡는 방법입니다.

**응답시간**

기존 GC는 전체 Heap을 대상으로 GC를 수행해야 했지만, G1 GC는 필요한 Region만 선택하여 GC 수행!
즉 한 번의 GC 작업으로 처리해야 할 데이터량을 줄여 STW 시간을 단축함

**처리량**
Old Generation을 한꺼번에 정리하지 않고, 가비지가 많은 Region을 "조금씩" 정리


## 6. ZGC

응답시간을 10ms이하로 만드는 응답시간의 괴물이라고 볼 수 있습니다. G1 GC와 비슷한 방식



# 🗽 결론 



응답시간이 빠른 GC는 결국 GC가 어플리케이션과 동시에 수행되거나 자주 수행이 됩니다. 그렇기에 애플리케이션이 사용할 CPU를 같이 쓰게된다.
그러면 애플리케이션이 사용할 CPU까지 쓰기에 전체적인 시스템이 처리량이 감소하는 것이다.

그 반대로 처리량이 크다는 것은 GC를 최대한 적게 실행하고 한번 실행할 때 많은 객체를 정리하는 게 목표입니다. 하지만 이렇게 되면 Old 영역이 꽉 찰때까지 기다려야되기에 멈추는 시간이 길어지는, 즉 응답시간이 길어지게 되죠.

결국 사용자인 우리는 둘 사이에서 환경에 맞게 사용해야됩니다.

JDK 8의 기본 GC는 Parellel GC이고 그 이후는 G1 GC로 기본값이 세팅되어 있습니다. 그 이유는 G1 GC가 처리량과 응답시간 두 부분다 우수한 평균적인 GC입니다.

